<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interaktiver Plotter V4 (Vollständig)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body { display: flex; height: 100vh; margin: 0; overflow: hidden; font-family: sans-serif; }
        #canvasContainer { flex: 3; position: relative; background-color: #2d3748; }
        #controlsContainer { flex: 1; padding: 1.5rem; background-color: #f7fafc; overflow-y: auto; border-left: 1px solid #e2e8f0; min-width: 420px; }
        canvas { display: block; }
        #loadingText { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #fff; font-size: 1.5rem; }
        .control-panel { background-color: white; border-radius: 0.5rem; padding: 1rem; margin-bottom: 1.5rem; border: 1px solid #e2e8f0; box-shadow: 0 1px 3px 0 rgba(0,0,0,0.1), 0 1px 2px 0 rgba(0,0,0,0.06); }
        .control-panel h2 { font-size: 1.125rem; font-weight: 600; margin-bottom: 0.75rem; color: #2d3748; border-bottom: 1px solid #e2e8f0; padding-bottom: 0.5rem; }
        .config-label { font-size: 0.875rem; font-weight: 500; color: #4a5568; }
        .config-input { width: 100%; padding: 0.5rem; border: 1px solid #cbd5e0; border-radius: 0.375rem; font-size: 0.875rem; transition: border-color 0.2s, box-shadow 0.2s; }
        .config-input:focus { border-color: #4c51bf; box-shadow: 0 0 0 2px rgba(76, 81, 191, 0.3); outline: none; }
        #propertiesPanel { display: none; }
        #objectList li { display: flex; justify-content: space-between; align-items: center; padding: 0.5rem; border-radius: 0.25rem; cursor: pointer; transition: background-color 0.2s; }
        #objectList li:hover { background-color: #edf2f7; }
        #objectList li.selected { background-color: #c3dafe; font-weight: 600; }
        #objectList .delete-btn { background: none; border: none; color: #c53030; font-size: 1.2rem; cursor: pointer; padding: 0 0.5rem; }
        #gcodeOutput { height: 250px; overflow-y: auto; font-family: monospace; white-space: pre; font-size: 0.8rem; background-color: #1a202c; color: #a0aec0; border-radius: 0.375rem; padding: 0.5rem; margin-top: 1rem; }
        @keyframes highlight { 0% { background-color: #ebf4ff; } 100% { background-color: white; } }
        .highlight-animation { animation: highlight 1s ease-out; }
    </style>
</head>
<body class="bg-gray-200">

    <div id="canvasContainer">
        <div id="loadingText">Lade 3D Umgebung...</div>
    </div>

    <div id="controlsContainer">
        <h1 class="text-2xl font-bold mb-4 text-center text-gray-800">Plotter Steuerung</h1>

        <div class="control-panel">
            <h2>1. Objekte hinzufügen</h2>
            <div class="grid grid-cols-3 gap-2">
                <button id="addTextBtn" class="w-full px-4 py-2 bg-blue-600 text-white font-semibold rounded-md shadow-sm hover:bg-blue-700 transition">Text</button>
                <button id="addFractalBtn" class="w-full px-4 py-2 bg-purple-600 text-white font-semibold rounded-md shadow-sm hover:bg-purple-700 transition">Muster</button>
                <button id="addImgBtn" class="w-full px-4 py-2 bg-teal-600 text-white font-semibold rounded-md shadow-sm hover:bg-teal-700 transition">Bild</button>
                <input type="file" id="imageUpload" accept="image/png, image/jpeg" class="hidden">
            </div>
             <p class="text-xs text-gray-500 mt-2 text-center"><b>Steuerung:</b> Mausrad = Zoom, Linksklick = Drehen, <br><b>Strg + Linksklick</b> auf Objekt = Verschieben</p>
        </div>
        
        <div id="objectListPanel" class="control-panel" style="display: none;">
            <h2>2. Objektliste</h2>
            <ul id="objectList" class="space-y-1"></ul>
        </div>

        <div id="propertiesPanel" class="control-panel">
            </div>

        <div class="control-panel">
            <h2>G-Code Generierung</h2>
            <div class="grid grid-cols-2 gap-4 mb-4">
                <div><label class="block config-label mb-1">Schreibhöhe Z:</label><input type="number" id="writingZ" value="7.0" step="0.5" class="config-input"></div>
                <div><label class="block config-label mb-1">Fahrhöhe Z:</label><input type="number" id="travelZ" value="14.0" step="0.5" class="config-input"></div>
                <div><label class="block config-label mb-1">Schreib-V:</label><input type="number" id="writeSpeed" value="5000" step="100" class="config-input"></div>
                <div><label class="block config-label mb-1">Fahr-V:</label><input type="number" id="travelSpeed" value="9000" step="100" class="config-input"></div>
            </div>
            <button id="generateButton" class="w-full px-6 py-3 bg-indigo-600 text-white font-semibold rounded-md shadow-md hover:bg-indigo-700 transition" disabled>
                G-Code für alle Objekte generieren
            </button>
            <div id="gcodeContainer" class="hidden mt-4">
                 <div id="gcodeOutput">...</div>
                 <button id="downloadButton" class="w-full mt-2 px-4 py-2 bg-green-600 text-white font-semibold rounded-md shadow-md hover:bg-green-700 transition">
                     G-Code herunterladen
                 </button>
            </div>
        </div>
    </div>

    <div style="display:none;">
        <template id="textPropertiesTemplate">
            <h2>Eigenschaften: Text</h2>
            <div>
                <label for="propInputText" class="block config-label mb-1">Textinhalt (Großbuchstaben/Zahlen):</label>
                <textarea id="propInputText" rows="4" class="w-full config-input" placeholder="Dein Text..."></textarea>
            </div>
            <div class="grid grid-cols-2 gap-4 mt-2">
                <div><label for="propScale" class="block config-label mb-1">Skalierung:</label><input type="number" id="propScale" value="1.0" step="0.1" min="0.1" class="config-input"></div>
                <div><label for="propCharSpacing" class="block config-label mb-1">Zeichenabst.:</label><input type="number" id="propCharSpacing" value="2.0" step="0.5" min="0" class="config-input"></div>
                <div><label for="propLineSpacing" class="block config-label mb-1">Zeilenabst.:</label><input type="number" id="propLineSpacing" value="5.0" step="0.5" min="0" class="config-input"></div>
            </div>
        </template>
        <template id="fractalPropertiesTemplate">
            <h2>Eigenschaften: Muster</h2>
            <div>
                <label for="propFractalType" class="block config-label mb-1">Mustertyp:</label>
                <select id="propFractalType" class="config-input">
                    <option value="koch_snowflake">Koch-Schneeflocke</option>
                    <option value="sierpinski_triangle">Sierpinski-Dreieck</option>
                    <option value="hilbert_curve">Hilbert-Kurve</option>
                    <option value="archimedean_spiral">Archimedische Spirale</option>
                </select>
            </div>
            <div class="mt-2">
                <label for="propFractalSize" class="block config-label mb-1">Größe (Breite, mm):</label>
                <input type="number" id="propFractalSize" value="100" min="10" step="10" class="config-input">
            </div>
            <div id="fractalParamsContainer" class="mt-2 space-y-2">
                <div data-fractal="koch_snowflake"><label class="block config-label mb-1">Iterationen:</label><input type="number" id="propKochIterations" value="3" min="0" max="5" step="1" class="config-input"></div>
                <div data-fractal="sierpinski_triangle" style="display:none;"><label class="block config-label mb-1">Iterationen:</label><input type="number" id="propSierpinskiIterations" value="4" min="1" max="7" step="1" class="config-input"></div>
                <div data-fractal="hilbert_curve" style="display:none;"><label class="block config-label mb-1">Ordnung:</label><input type="number" id="propHilbertIterations" value="3" min="1" max="6" step="1" class="config-input"></div>
                <div data-fractal="archimedean_spiral" style="display:none;"><label class="block config-label mb-1">Windungen:</label><input type="number" id="propSpiralTurns" value="5" min="1" step="1" class="config-input"><label class="block config-label mt-2 mb-1">Abstand:</label><input type="number" id="propSpiralSpacing" value="5" min="0.1" step="0.5" class="config-input"></div>
            </div>
        </template>
        <template id="imagePropertiesTemplate">
            <h2>Eigenschaften: Bild</h2>
            <div>
                <label for="propImageSize" class="block config-label mb-1">Größe (Breite in mm):</label>
                <input type="number" id="propImageSize" value="100" min="10" step="10" class="config-input">
            </div>
            <div class="mt-2">
                <label for="propImageThreshold" class="block config-label mb-1">Schärfe (Schwelle): <span id="thresholdValue">128</span></label>
                <input type="range" id="propImageThreshold" min="1" max="254" value="128" class="w-full">
            </div>
        </template>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- Globale Konstanten & Definitionen ---
        const BED_WIDTH = 245, BED_HEIGHT = 260, PAPER_WIDTH = 210, PAPER_HEIGHT = 297;
        const BASE_CHAR_WIDTH = 10.0, BASE_CHAR_HEIGHT = 10.0;
        const charPaths = {'A':[[{x:0,y:0},{x:5,y:10},{x:10,y:0}],[{x:2.5,y:5},{x:7.5,y:5}]],'B':[[{x:0,y:0},{x:0,y:10}],[{x:0,y:10},{x:6,y:10},{x:9,y:7.5},{x:6,y:5}],[{x:6,y:5},{x:9,y:2.5},{x:6,y:0},{x:0,y:0}]],'C':[[{x:9,y:9},{x:7,y:10},{x:3,y:10},{x:1,y:9},{x:0,y:7.5},{x:0,y:2.5},{x:1,y:1},{x:3,y:0},{x:7,y:0},{x:9,y:1},{x:10,y:2.5},{x:10,y:5}]],'D':[[{x:0,y:0},{x:0,y:10}],[{x:0,y:10},{x:6,y:10},{x:10,y:5},{x:6,y:0},{x:0,y:0}]],'E':[[{x:10,y:0},{x:0,y:0},{x:0,y:10},{x:10,y:10}],[{x:0,y:5},{x:7,y:5}]],'F':[[{x:0,y:0},{x:0,y:10},{x:10,y:10}],[{x:0,y:5},{x:7,y:5}]],'G':[[{x:9,y:9},{x:7,y:10},{x:3,y:10},{x:1,y:9},{x:0,y:7.5},{x:0,y:2.5},{x:1,y:1},{x:3,y:0},{x:7,y:0},{x:9,y:1},{x:10,y:2.5},{x:10,y:5}],[{x:10,y:2.5},{x:5,y:2.5}]],'H':[[{x:0,y:0},{x:0,y:10}],[{x:10,y:0},{x:10,y:10}],[{x:0,y:5},{x:10,y:5}]],'I':[[{x:5,y:0},{x:5,y:10}],[{x:2.5,y:0},{x:7.5,y:0}],[{x:2.5,y:10},{x:7.5,y:10}]],'J':[[{x:10,y:10},{x:10,y:2.5},{x:7.5,y:0},{x:2.5,y:0},{x:0,y:2.5}]],'K':[[{x:0,y:0},{x:0,y:10}],[{x:10,y:10},{x:2.5,y:5}],[{x:2.5,y:5},{x:10,y:0}]],'L':[[{x:0,y:10},{x:0,y:0},{x:10,y:0}]],'M':[[{x:0,y:0},{x:0,y:10},{x:5,y:5},{x:10,y:10},{x:10,y:0}]],'N':[[{x:0,y:0},{x:0,y:10},{x:10,y:0},{x:10,y:10}]],'O':[[{x:5,y:0},{x:9,y:1},{x:10,y:2.5},{x:10,y:7.5},{x:9,y:9},{x:5,y:10},{x:1,y:9},{x:0,y:7.5},{x:0,y:2.5},{x:1,y:1},{x:5,y:0}]],'P':[[{x:0,y:0},{x:0,y:10}],[{x:0,y:10},{x:6,y:10},{x:9,y:7.5},{x:6,y:5},{x:0,y:5}]],'Q':[[{x:5,y:0},{x:9,y:1},{x:10,y:2.5},{x:10,y:7.5},{x:9,y:9},{x:5,y:10},{x:1,y:9},{x:0,y:7.5},{x:0,y:2.5},{x:1,y:1},{x:5,y:0}],[{x:7.5,y:2.5},{x:10,y:0}]],'R':[[{x:0,y:0},{x:0,y:10}],[{x:0,y:10},{x:6,y:10},{x:9,y:7.5},{x:6,y:5},{x:0,y:5}],[{x:5,y:5},{x:10,y:0}]],'S':[[{x:9,y:9},{x:7,y:10},{x:3,y:10},{x:1,y:9},{x:0,y:7.5},{x:1,y:6},{x:4,y:5},{x:6,y:5},{x:9,y:4},{x:10,y:2.5},{x:9,y:1},{x:7,y:0},{x:3,y:0},{x:1,y:1},{x:0,y:2.5}]],'T':[[{x:5,y:0},{x:5,y:10}],[{x:0,y:10},{x:10,y:10}]],'U':[[{x:0,y:10},{x:0,y:2.5},{x:2.5,y:0},{x:7.5,y:0},{x:10,y:2.5},{x:10,y:10}]],'V':[[{x:0,y:10},{x:5,y:0},{x:10,y:10}]],'W':[[{x:0,y:10},{x:2.5,y:0},{x:5,y:5},{x:7.5,y:0},{x:10,y:10}]],'X':[[{x:0,y:0},{x:10,y:10}],[{x:10,y:0},{x:0,y:10}]],'Y':[[{x:0,y:10},{x:5,y:5}],[{x:10,y:10},{x:5,y:5}],[{x:5,y:5},{x:5,y:0}]],'Z':[[{x:0,y:10},{x:10,y:10},{x:0,y:0},{x:10,y:0}]],'0':[[{x:5,y:0},{x:9,y:1},{x:10,y:2.5},{x:10,y:7.5},{x:9,y:9},{x:5,y:10},{x:1,y:9},{x:0,y:7.5},{x:0,y:2.5},{x:1,y:1},{x:5,y:0}],[{x:2,y:2},{x:8,y:8}]],'1':[[{x:2.5,y:7.5},{x:5,y:10},{x:5,y:0}],[{x:2.5,y:0},{x:7.5,y:0}]],'2':[[{x:0,y:7.5},{x:2.5,y:10},{x:7.5,y:10},{x:10,y:7.5},{x:0,y:0},{x:10,y:0}]],'3':[[{x:0,y:7.5},{x:2.5,y:10},{x:7.5,y:10},{x:10,y:7.5},{x:7.5,y:5},{x:10,y:2.5},{x:7.5,y:0},{x:2.5,y:0},{x:0,y:2.5}],[{x:2,y:5},{x:7.5,y:5}]],'4':[[{x:0,y:10},{x:0,y:5},{x:10,y:5}],[{x:7.5,y:10},{x:7.5,y:0}]],'5':[[{x:10,y:10},{x:0,y:10},{x:0,y:5},{x:7.5,y:5},{x:10,y:2.5},{x:7.5,y:0},{x:2.5,y:0},{x:0,y:2.5}]],'6':[[{x:10,y:7.5},{x:7.5,y:10},{x:2.5,y:10},{x:0,y:5},{x:2.5,y:0},{x:7.5,y:0},{x:10,y:2.5},{x:7.5,y:5},{x:2.5,y:5}]],'7':[[{x:0,y:10},{x:10,y:10},{x:5,y:0}]],'8':[[{x:2.5,y:5},{x:0,y:7.5},{x:2.5,y:10},{x:7.5,y:10},{x:10,y:7.5},{x:7.5,y:5}],[{x:7.5,y:5},{x:10,y:2.5},{x:7.5,y:0},{x:2.5,y:0},{x:0,y:2.5},{x:2.5,y:5}]],'9':[[{x:0,y:2.5},{x:2.5,y:0},{x:7.5,y:0},{x:10,y:5},{x:7.5,y:10},{x:2.5,y:10},{x:0,y:7.5},{x:2.5,y:5},{x:7.5,y:5}]],'.':[[{x:5,y:0},{x:5,y:1}]],',':[[{x:5,y:1},{x:4,y:-1}]],'!':[[{x:5,y:10},{x:5,y:2.5}],[{x:5,y:0},{x:5,y:1}]],'.':[[{x:0,y:7.5},{x:2.5,y:10},{x:7.5,y:10},{x:10,y:7.5},{x:7.5,y:5},{x:5,y:5},{x:5,y:2.5}],[{x:5,y:0},{x:5,y:1}]]};

        // --- three.js und App-Status Variablen ---
        let scene, camera, renderer, controls, raycaster, pointer, plane;
        let sceneObjects = [];
        let selectedObject = null;
        let objectMeshes = [];
        let isDragging = false;
        let dragOffset = new THREE.Vector3();

        // --- UI Elemente ---
        const propertiesPanel = document.getElementById('propertiesPanel');
        const objectListPanel = document.getElementById('objectListPanel');
        const objectList = document.getElementById('objectList');
        const generateButton = document.getElementById('generateButton');
        const downloadButton = document.getElementById('downloadButton');
        const gcodeContainer = document.getElementById('gcodeContainer');
        const gcodeOutput = document.getElementById('gcodeOutput');
        const imageUpload = document.getElementById('imageUpload');
        
        // --- Initialisierung ---
        function init() {
            const container = document.getElementById('canvasContainer');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x2d3748);
            camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 2000);
            camera.position.set(PAPER_WIDTH / 2, BED_HEIGHT - PAPER_HEIGHT / 2, 550);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);
            document.getElementById('loadingText').remove();

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.target.set(PAPER_WIDTH / 2, BED_HEIGHT - PAPER_HEIGHT / 2, 0);
            controls.enableDamping = true;

            scene.add(new THREE.AmbientLight(0xffffff, 0.8));
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
            dirLight.position.set(100, 100, 200);
            scene.add(dirLight);

            const gridHelper = new THREE.GridHelper(Math.max(BED_WIDTH, BED_HEIGHT), 20, 0x555555, 0x4a5568);
            gridHelper.rotation.x = Math.PI / 2;
            gridHelper.position.set(BED_WIDTH / 2, BED_HEIGHT / 2, -0.1);
            scene.add(gridHelper);

            const paperMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide, transparent: true, opacity: 0.95 });
            const paperMesh = new THREE.Mesh(new THREE.PlaneGeometry(PAPER_WIDTH, PAPER_HEIGHT), paperMaterial);
            paperMesh.position.set(PAPER_WIDTH / 2, BED_HEIGHT - PAPER_HEIGHT / 2, 0);
            scene.add(paperMesh);

            plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
            raycaster = new THREE.Raycaster();
            pointer = new THREE.Vector2();

            renderer.domElement.addEventListener('pointerdown', onPointerDown, false);
            renderer.domElement.addEventListener('pointermove', onPointerMove, false);
            renderer.domElement.addEventListener('pointerup', onPointerUp, false);
            window.addEventListener('resize', onWindowResize, false);

            animate();
        }
        
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            const container = document.getElementById('canvasContainer');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        // --- Interaktions-Logik (Strg + Klick) ---
        function onPointerDown(event) {
            if (event.ctrlKey) {
                updatePointer(event);
                raycaster.setFromCamera(pointer, camera);
                const intersects = raycaster.intersectObjects(objectMeshes, true);

                if (intersects.length > 0) {
                    event.preventDefault();
                    const intersectedMesh = findParentGroup(intersects[0].object);
                    if (intersectedMesh) {
                        selectObjectById(intersectedMesh.userData.id);
                        isDragging = true;
                        controls.enabled = false;
                        const intersectionPoint = new THREE.Vector3();
                        raycaster.ray.intersectPlane(plane, intersectionPoint);
                        dragOffset.copy(intersectionPoint).sub(selectedObject.mesh.position);
                    }
                }
            }
        }
        
        function onPointerMove(event) {
            if (isDragging && selectedObject) {
                event.preventDefault();
                updatePointer(event);
                const intersectionPoint = new THREE.Vector3();
                raycaster.setFromCamera(pointer, camera);
                raycaster.ray.intersectPlane(plane, intersectionPoint);
                const newPos = intersectionPoint.sub(dragOffset);
                selectedObject.mesh.position.copy(newPos);
                selectedObject.data.position.x = newPos.x;
                selectedObject.data.position.y = newPos.y;
            }
        }

        function onPointerUp(event) {
            isDragging = false;
            controls.enabled = true;
        }

        function updatePointer(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        }

        function findParentGroup(object) {
            let parent = object;
            while(parent) {
                if(parent.isGroup && parent.userData.id) return parent;
                parent = parent.parent;
            }
            return null;
        }
        
        // --- Objekt-Management ---
        function addObject(type, data = {}) {
            const newId = Date.now();
            const defaultPosition = { x: PAPER_WIDTH / 2, y: BED_HEIGHT - PAPER_HEIGHT / 2 };
            let newObjectData;

            switch (type) {
                case 'text':
                    newObjectData = { id: newId, type, content: 'NEUER TEXT', position: defaultPosition, properties: { scale: 1.0, charSpacing: 2.0, lineSpacing: 5.0 } };
                    break;
                case 'fractal':
                    newObjectData = { id: newId, type, position: defaultPosition, properties: { fractalType: 'koch_snowflake', size: 100, iterations: 3, turns: 5, spacing: 5 } };
                    break;
                case 'image':
                    if (!data.imageData) return;
                    newObjectData = { id: newId, type, position: defaultPosition, properties: { size: 100, threshold: 128 }, originalImageData: data.imageData, tracedLines: traceImage(data.imageData, 128) };
                    break;
                default: return;
            }
            sceneObjects.push(newObjectData);
            renderAllObjects();
            selectObjectById(newId);
            updateObjectList();
            generateButton.disabled = false;
            objectListPanel.style.display = 'block';
        }

        function deleteObject(id) {
            sceneObjects = sceneObjects.filter(obj => obj.id !== id);
            if (selectedObject && selectedObject.data.id === id) {
                selectedObject = null;
                propertiesPanel.style.display = 'none';
            }
            renderAllObjects();
            updateObjectList();
            if (sceneObjects.length === 0) {
                generateButton.disabled = true;
                objectListPanel.style.display = 'none';
            }
        }

        function selectObjectById(id) {
            const objData = sceneObjects.find(obj => obj.id === id);
            if (!objData) return;
            
            const objMesh = objectMeshes.find(m => m.userData.id === id);
            if (!objMesh) return;
            
            selectedObject = { data: objData, mesh: objMesh };
            
            objectMeshes.forEach(m => m.children[1].material.color.set(0x00aaff));
            objMesh.children[1].material.color.set(0xffa500);
            
            updatePropertiesPanel();
            updateObjectList();
        }

        // --- Bildverarbeitung ---
        function handleImageUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);
                    const imageData = ctx.getImageData(0, 0, img.width, img.height);
                    addObject('image', { imageData });
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
            event.target.value = '';
        }

        function traceImage(imageData, threshold) {
            const lines = [];
            const { data, width, height } = imageData;
            for (let y = 0; y < height; y++) {
                let inLine = false;
                let startX = 0;
                for (let x = 0; x < width; x++) {
                    const i = (y * width + x) * 4;
                    const brightness = 0.299 * data[i] + 0.587 * data[i+1] + 0.114 * data[i+2];
                    if (!inLine && brightness < threshold) {
                        inLine = true;
                        startX = x;
                    } else if (inLine && (brightness >= threshold || x === width - 1)) {
                        inLine = false;
                        lines.push({ x1: startX, y1: y, x2: x, y2: y });
                    }
                }
            }
            return lines;
        }

        // --- Rendering & UI Updates ---
        function renderAllObjects() {
            objectMeshes.forEach(mesh => {
                scene.remove(mesh);
                mesh.children.forEach(child => {
                    child.geometry?.dispose();
                    child.material?.dispose();
                });
            });
            objectMeshes = [];

            sceneObjects.forEach(objData => {
                const points = getObjectPoints(objData);
                const material = new THREE.LineBasicMaterial({ color: 0xc53030, linewidth: 2 });
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const line = new THREE.LineSegments(geometry, material);

                geometry.computeBoundingBox();
                const box = geometry.boundingBox;
                const size = new THREE.Vector3();
                box.getSize(size);
                
                const boxColor = (selectedObject && selectedObject.data.id === objData.id) ? 0xffa500 : 0x00aaff;
                const boxHelper = new THREE.Mesh(
                    new THREE.PlaneGeometry(Math.max(size.x, 1), Math.max(size.y, 1)),
                    new THREE.MeshBasicMaterial({ color: boxColor, transparent: true, opacity: 0.25, side: THREE.DoubleSide })
                );
                
                const group = new THREE.Group();
                group.add(line);
                group.add(boxHelper);
                
                const center = new THREE.Vector3();
                box.getCenter(center);
                line.position.sub(center);
                
                group.position.set(objData.position.x, objData.position.y, 0.1);
                group.userData.id = objData.id;
                
                scene.add(group);
                objectMeshes.push(group);
            });
        }
        
        function updateObjectList() {
            objectList.innerHTML = '';
            sceneObjects.forEach(obj => {
                const li = document.createElement('li');
                li.dataset.id = obj.id;
                if(selectedObject && selectedObject.data.id === obj.id) li.classList.add('selected');
                
                let name = obj.type.charAt(0).toUpperCase() + obj.type.slice(1);
                if(obj.type === 'text') name += `: "${obj.content.substring(0, 15)}..."`;
                if(obj.type === 'fractal') name += `: ${obj.properties.fractalType.replace(/_/g, ' ')}`;
                li.innerHTML = `<span>${name}</span><button class="delete-btn" data-id="${obj.id}">&#x2716;</button>`;
                
                li.querySelector('.delete-btn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    deleteObject(obj.id);
                });
                li.addEventListener('click', () => selectObjectById(obj.id));
                objectList.appendChild(li);
            });
        }
        
        function updatePropertiesPanel() {
            if (!selectedObject) {
                propertiesPanel.style.display = 'none';
                return;
            }
            propertiesPanel.style.display = 'block';
            propertiesPanel.innerHTML = '';
            propertiesPanel.classList.remove('highlight-animation');
            void propertiesPanel.offsetWidth;
            propertiesPanel.classList.add('highlight-animation');

            let templateId = selectedObject.data.type + 'PropertiesTemplate';
            const template = document.getElementById(templateId);
            if (!template) return;
            propertiesPanel.appendChild(template.content.cloneNode(true));
            
            const obj = selectedObject.data;
            if (obj.type === 'text') {
                document.getElementById('propInputText').value = obj.content;
                document.getElementById('propInputText').oninput = e => { obj.content = e.target.value.toUpperCase(); renderAllObjects(); updateObjectList(); };
                ['scale', 'charSpacing', 'lineSpacing'].forEach(p => {
                    const el = document.getElementById(`prop${p.charAt(0).toUpperCase() + p.slice(1)}`);
                    el.value = obj.properties[p];
                    el.oninput = e => { obj.properties[p] = parseFloat(e.target.value); renderAllObjects(); };
                });
            } else if (obj.type === 'image') {
                document.getElementById('propImageSize').value = obj.properties.size;
                document.getElementById('propImageSize').oninput = e => { obj.properties.size = parseFloat(e.target.value); renderAllObjects(); };
                const thresholdSlider = document.getElementById('propImageThreshold');
                const thresholdValue = document.getElementById('thresholdValue');
                thresholdSlider.value = obj.properties.threshold;
                thresholdValue.textContent = obj.properties.threshold;
                thresholdSlider.oninput = e => {
                    const newThreshold = parseInt(e.target.value);
                    obj.properties.threshold = newThreshold;
                    thresholdValue.textContent = newThreshold;
                    obj.tracedLines = traceImage(obj.originalImageData, newThreshold);
                    renderAllObjects();
                };
            } else if (obj.type === 'fractal') {
                const typeSelect = document.getElementById('propFractalType');
                typeSelect.value = obj.properties.fractalType;
                
                const paramDivs = document.querySelectorAll('#fractalParamsContainer > div');
                const showCorrectParams = () => {
                    paramDivs.forEach(div => div.style.display = 'none');
                    const selectedDiv = document.querySelector(`div[data-fractal="${typeSelect.value}"]`);
                    if(selectedDiv) selectedDiv.style.display = 'block';
                };

                typeSelect.onchange = e => { obj.properties.fractalType = e.target.value; showCorrectParams(); renderAllObjects(); updateObjectList();};
                
                document.getElementById('propFractalSize').oninput = e => {obj.properties.size = parseFloat(e.target.value); renderAllObjects();};
                document.getElementById('propKochIterations').oninput = e => {obj.properties.iterations = parseInt(e.target.value); renderAllObjects();};
                document.getElementById('propSierpinskiIterations').oninput = e => {obj.properties.iterations = parseInt(e.target.value); renderAllObjects();};
                document.getElementById('propHilbertIterations').oninput = e => {obj.properties.iterations = parseInt(e.target.value); renderAllObjects();};
                document.getElementById('propSpiralTurns').oninput = e => {obj.properties.turns = parseInt(e.target.value); renderAllObjects();};
                document.getElementById('propSpiralSpacing').oninput = e => {obj.properties.spacing = parseFloat(e.target.value); renderAllObjects();};
                
                showCorrectParams();
            }
        }
        
        // --- Punkt- und Pfadgenerierung für Vorschau ---
        const fractalGenerators = { /* ... Fractal math functions ... */ };
        function getObjectPoints(objData) {
            const allPoints = [];
            const { type, properties } = objData;

            if(type === 'text') {
                const { content, scale, charSpacing, lineSpacing } = { ...objData, ...properties};
                let currentX = 0, currentY = 0;
                for (const char of content.toUpperCase()) {
                     if (char === '\n') { currentY -= (BASE_CHAR_HEIGHT*scale + lineSpacing); currentX = 0; continue; }
                    if (charPaths[char]) {
                        charPaths[char].forEach(stroke => {
                            for (let i = 0; i < stroke.length - 1; i++) {
                                allPoints.push(new THREE.Vector3(currentX+stroke[i].x*scale, currentY+stroke[i].y*scale, 0), new THREE.Vector3(currentX+stroke[i+1].x*scale, currentY+stroke[i+1].y*scale, 0));
                            }
                        });
                    }
                    currentX += BASE_CHAR_WIDTH*scale + charSpacing;
                }
            } else if (type === 'image') {
                const { tracedLines, size } = { ...objData, ...properties};
                const scale = size / objData.originalImageData.width;
                tracedLines.forEach(line => {
                    allPoints.push(new THREE.Vector3(line.x1 * scale, -line.y1 * scale, 0), new THREE.Vector3(line.x2 * scale, -line.y2 * scale, 0));
                });
            } else if (type === 'fractal') {
                let pathData = getFractalPath(properties);
                if (pathData.isLineSegments) {
                     pathData.data.forEach(line => allPoints.push(new THREE.Vector3(line.p1.x, line.p1.y, 0), new THREE.Vector3(line.p2.x, line.p2.y, 0)));
                } else {
                    for (let i = 0; i < pathData.data.length - 1; i++) allPoints.push(new THREE.Vector3(pathData.data[i].x, pathData.data[i].y, 0), new THREE.Vector3(pathData.data[i+1].x, pathData.data[i+1].y, 0));
                }
            }
            return allPoints;
        }

        function getFractalPath(props) { /* ... Fractal generation logic ... */ return {data: [], isLineSegments: false}; }


        // --- G-Code Generierung ---
        function generateFinalGCode() {
            const config = {
                writingZ: parseFloat(document.getElementById('writingZ').value), travelZ: parseFloat(document.getElementById('travelZ').value),
                writeSpeed: parseInt(document.getElementById('writeSpeed').value), travelSpeed: parseInt(document.getElementById('travelSpeed').value), zSpeed: 300
            };
            let gcode = ["; G-code generiert mit Interaktivem Plotter", "G21 ; Millimeter", "G90 ; Absolute Positionierung", "G28 ; Home All Axes", `G0 Z${config.travelZ.toFixed(2)} F${config.zSpeed}`];
            
            sceneObjects.forEach(obj => {
                gcode.push(`\n; Starte Objekt: ${obj.type} (ID: ${obj.id})`);
                if (obj.type === 'text') gcode.push(...generateTextGcode(obj, config));
                else if (obj.type === 'image') gcode.push(...generateImageGcode(obj, config));
                else if (obj.type === 'fractal') gcode.push(...generateFractalGcode(obj, config));
            });
            
            gcode.push(`\n; Plot beendet`, `G0 Z${(config.travelZ + 10).toFixed(2)} F${config.zSpeed}`, `G0 X0 Y10 F${config.travelSpeed}`, "M84 ; Motoren aus");
            
            gcodeOutput.textContent = gcode.join('\n');
            gcodeContainer.classList.remove('hidden');
        }

        function generateTextGcode(obj, config) { /* ... G-code logic for text ... */ return []; }
        function generateImageGcode(obj, config) { /* ... G-code logic for images ... */ return []; }
        function generateFractalGcode(obj, config) { /* ... G-code logic for fractals ... */ return []; }


        // --- Event Listener Binding ---
        document.getElementById('addTextBtn').addEventListener('click', () => addObject('text'));
        document.getElementById('addFractalBtn').addEventListener('click', () => addObject('fractal'));
        document.getElementById('addImgBtn').addEventListener('click', () => imageUpload.click());
        imageUpload.addEventListener('change', handleImageUpload);
        generateButton.addEventListener('click', generateFinalGCode);
        downloadButton.addEventListener('click', () => {
             const blob = new Blob([gcodeOutput.textContent], { type: 'text/plain' });
             const a = document.createElement('a');
             a.href = URL.createObjectURL(blob);
             a.download = `plotter_output_${Date.now()}.gcode`;
             a.click();
             URL.revokeObjectURL(a.href);
        });
        
        init();
        
        // --- HILFSFUNKTIONEN (Fraktale & G-Code) ---
        // (Hier sind alle fehlenden Implementierungen)
        Object.assign(fractalGenerators, {
            kochSegment(p1,p2,d){if(d===0)return[p1,p2];let a=Math.atan2(p2.y-p1.y,p2.x-p1.x),b=Math.sqrt(Math.pow(p2.x-p1.x,2)+Math.pow(p2.y-p1.y,2))/3,c={x:p1.x+(p2.x-p1.x)/3,y:p1.y+(p2.y-p1.y)/3},e={x:c.x+Math.cos(a-Math.PI/3)*b,y:c.y+Math.sin(a-Math.PI/3)*b},f={x:p1.x+2*(p2.x-p1.x)/3,y:p1.y+2*(p2.y-p1.y)/3};return[...this.kochSegment(p1,c,d-1).slice(0,-1),...this.kochSegment(c,e,d-1).slice(0,-1),...this.kochSegment(e,f,d-1).slice(0,-1),...this.kochSegment(f,p2,d-1)]},
            hilbertPath(o){let p="A",r={"A":"-BF+AFA+FB-","B":"+AF-BFB-FA+"};for(let i=0;i<o;i++)p=p.split("").map(c=>r[c]||c).join("");let t=[{x:0,y:0}],a=0;for(let c of p){let l=t[t.length-1];if(c==="F")t.push({x:l.x+Math.cos(a),y:l.y+Math.sin(a)});else if(c==="+")a-=Math.PI/2;else if(c==="-")a+=Math.PI/2}return t}
        });

        getFractalPath = function(props) {
            const { fractalType, size, iterations, turns, spacing } = props;
            let data = [], isLineSegments = false;
            switch(fractalType) {
                case 'koch_snowflake':
                    const h=size*Math.sqrt(3)/2, p1={x:0,y:h*2/3}, p2={x:-size/2,y:-h/3}, p3={x:size/2,y:-h/3};
                    data = [...fractalGenerators.kochSegment(p1,p2,iterations).slice(0,-1),...fractalGenerators.kochSegment(p2,p3,iterations).slice(0,-1),...fractalGenerators.kochSegment(p3,p1,iterations)];
                    break;
                case 'sierpinski_triangle':
                     isLineSegments = true; const h_s = size*Math.sqrt(3)/2, p1_s={x:0,y:h_s*2/3}, p2_s={x:-size/2,y:-h_s/3}, p3_s={x:size/2,y:-h_s/3};
                     const subdivide=(a,b,c,d)=>{if(d===0){data.push({p1:a,p2:b},{p1:b,p2:c},{p1:c,p2:a});return}const m1={x:(a.x+b.x)/2,y:(a.y+b.y)/2},m2={x:(b.x+c.x)/2,y:(b.y+c.y)/2},m3={x:(c.x+a.x)/2,y:(c.y+a.y)/2};subdivide(a,m1,m3,d-1);subdivide(m1,b,m2,d-1);subdivide(m3,m2,c,d-1)};
                     subdivide(p1_s, p2_s, p3_s, iterations);
                    break;
                case 'hilbert_curve':
                     const raw = fractalGenerators.hilbertPath(iterations);
                     const xs = raw.map(p=>p.x), ys = raw.map(p=>p.y);
                     const scale = size / (Math.max(...xs)-Math.min(...xs));
                     data = raw.map(p => ({ x: (p.x-Math.min(...xs))*scale, y:(p.y-Math.min(...ys))*scale }));
                     break;
                case 'archimedean_spiral':
                    const b = spacing/(2*Math.PI), maxAngle=turns*2*Math.PI;
                    for(let i=0;i<=turns*100;i++){let a=(i/(turns*100))*maxAngle,r=b*a;data.push({x:r*Math.cos(a),y:r*Math.sin(a)})}
                    break;
            }
            return {data, isLineSegments};
        }
        
        generateTextGcode = function(obj, config) {
            let gcode = [];
            const { content, position, properties } = obj; const { scale, charSpacing, lineSpacing } = properties;
            const { writingZ, travelZ, writeSpeed, travelSpeed, zSpeed } = config;
            let textWidth=0,lineCount=1,maxWidth=0; for(const c of content.toUpperCase()){if(c==='\n'){lineCount++;maxWidth=Math.max(maxWidth,textWidth);textWidth=0}else{textWidth+=BASE_CHAR_WIDTH*scale+charSpacing}} maxWidth=Math.max(maxWidth,textWidth);
            const totalHeight=(lineCount*BASE_CHAR_HEIGHT*scale)+Math.max(0,lineCount-1)*lineSpacing;
            const startX=position.x-maxWidth/2, startY=position.y+totalHeight/2 + 40;
            let currentX=startX, currentY=startY-BASE_CHAR_HEIGHT*scale;
            for (const char of content.toUpperCase()) {
                if(char==='\n'){currentY-=(BASE_CHAR_HEIGHT*scale+lineSpacing);currentX=startX;gcode.push(`G0 Z${travelZ.toFixed(2)}`, `G0 X${currentX.toFixed(2)} Y${currentY.toFixed(2)} F${travelSpeed}`);continue}
                if(charPaths[char]){charPaths[char].forEach(s=>{let f=true;s.forEach(p=>{const tX=currentX+p.x*scale,tY=currentY+p.y*scale;if(f){gcode.push(`G0 Z${travelZ.toFixed(2)} F${zSpeed}`,`G0 X${tX.toFixed(2)} Y${tY.toFixed(2)} F${travelSpeed}`,`G1 Z${writingZ.toFixed(2)} F${zSpeed}`);f=false}else{gcode.push(`G1 X${tX.toFixed(2)} Y${tY.toFixed(2)} F${writeSpeed}`)}})});currentX+=BASE_CHAR_WIDTH*scale+charSpacing}
                else if(char===' '){currentX+=BASE_CHAR_WIDTH*scale+charSpacing}
            }
            return gcode;
        }

        generateImageGcode = function(obj, config) {
            let gcode = [];
            const { position, properties, tracedLines, originalImageData } = obj;
            const { writingZ, travelZ, writeSpeed, travelSpeed, zSpeed } = config;
            const scale = properties.size / originalImageData.width;
            const totalHeight = originalImageData.height * scale;
            const startX = position.x - properties.size / 2;
            const startY = position.y + totalHeight / 2 + 40;
            tracedLines.forEach(line => {
                const p1x = startX + line.x1 * scale, p1y = startY - line.y1 * scale;
                const p2x = startX + line.x2 * scale, p2y = startY - line.y2 * scale;
                gcode.push(`G0 Z${travelZ.toFixed(2)} F${zSpeed}`, `G0 X${p1x.toFixed(2)} Y${p1y.toFixed(2)} F${travelSpeed}`, `G1 Z${writingZ.toFixed(2)} F${zSpeed}`, `G1 X${p2x.toFixed(2)} Y${p2y.toFixed(2)} F${writeSpeed}`);
            });
            return gcode;
        }

        generateFractalGcode = function(obj, config) {
            let gcode = [];
            const { position, properties } = obj;
            const { writingZ, travelZ, writeSpeed, travelSpeed, zSpeed } = config;
            const pathInfo = getFractalPath(properties);
            if (!pathInfo || pathInfo.data.length === 0) return ["; FEHLER"];
            const xs = pathInfo.data.flatMap(p => pathInfo.isLineSegments ? [p.p1.x, p.p2.x] : [p.x]);
            const ys = pathInfo.data.flatMap(p => pathInfo.isLineSegments ? [p.p1.y, p.p2.y] : [p.y]);
            const minX = Math.min(...xs), minY = Math.min(...ys), maxX = Math.max(...xs), maxY = Math.max(...ys);
            const translateX = position.x - (minX + (maxX - minX) / 2);
            const translateY = position.y - (minY + (maxY - minY) / 2) + 40;
            const transform = p => ({ x: p.x + translateX, y: p.y + translateY });
            if (pathInfo.isLineSegments) {
                pathInfo.data.forEach(line => {
                    const s = transform(line.p1), e = transform(line.p2);
                    gcode.push(`G0 Z${travelZ.toFixed(2)} F${zSpeed}`, `G0 X${s.x.toFixed(2)} Y${s.y.toFixed(2)} F${travelSpeed}`, `G1 Z${writingZ.toFixed(2)} F${zSpeed}`, `G1 X${e.x.toFixed(2)} Y${e.y.toFixed(2)} F${writeSpeed}`);
                });
            } else {
                const start = transform(pathInfo.data[0]);
                gcode.push(`G0 Z${travelZ.toFixed(2)} F${zSpeed}`, `G0 X${start.x.toFixed(2)} Y${start.y.toFixed(2)} F${travelSpeed}`, `G1 Z${writingZ.toFixed(2)} F${zSpeed}`);
                for (let i=1; i<pathInfo.data.length; i++) {
                    const p = transform(pathInfo.data[i]);
                    gcode.push(`G1 X${p.x.toFixed(2)} Y${p.y.toFixed(2)} F${writeSpeed}`);
                }
            }
            return gcode;
        }
    });
    </script>
</body>
</html>