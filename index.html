<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interaktiver Plotter V4 (Vollständig)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body { display: flex; height: 100vh; margin: 0; overflow: hidden; font-family: sans-serif; }
        #canvasContainer { flex: 3; position: relative; background-color: #2d3748; }
        #controlsContainer { flex: 1; padding: 1.5rem; background-color: #f7fafc; overflow-y: auto; border-left: 1px solid #e2e8f0; min-width: 420px; }
        canvas { display: block; }
        #loadingText { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #fff; font-size: 1.5rem; }
        .control-panel { background-color: white; border-radius: 0.5rem; padding: 1rem; margin-bottom: 1.5rem; border: 1px solid #e2e8f0; box-shadow: 0 1px 3px 0 rgba(0,0,0,0.1), 0 1px 2px 0 rgba(0,0,0,0.06); }
        .control-panel h2 { font-size: 1.125rem; font-weight: 600; margin-bottom: 0.75rem; color: #2d3748; border-bottom: 1px solid #e2e8f0; padding-bottom: 0.5rem; }
        .config-label { font-size: 0.875rem; font-weight: 500; color: #4a5568; }
        .config-input { width: 100%; padding: 0.5rem; border: 1px solid #cbd5e0; border-radius: 0.375rem; font-size: 0.875rem; transition: border-color 0.2s, box-shadow 0.2s; }
        .config-input:focus { border-color: #4c51bf; box-shadow: 0 0 0 2px rgba(76, 81, 191, 0.3); outline: none; }
        #propertiesPanel { display: none; }
        #objectList li { display: flex; justify-content: space-between; align-items: center; padding: 0.5rem; border-radius: 0.25rem; cursor: pointer; transition: background-color 0.2s; }
        #objectList li:hover { background-color: #edf2f7; }
        #objectList li.selected { background-color: #c3dafe; font-weight: 600; }
        #objectList .delete-btn { background: none; border: none; color: #c53030; font-size: 1.2rem; cursor: pointer; padding: 0 0.5rem; }
        #gcodeOutput { height: 250px; overflow-y: auto; font-family: monospace; white-space: pre; font-size: 0.8rem; background-color: #1a202c; color: #a0aec0; border-radius: 0.375rem; padding: 0.5rem; margin-top: 1rem; }
        @keyframes highlight { 0% { background-color: #ebf4ff; } 100% { background-color: white; } }
        .highlight-animation { animation: highlight 1s ease-out; }
    </style>
</head>
<body class="bg-gray-200">

    <div id="canvasContainer">
        <div id="loadingText">Lade 3D Umgebung...</div>
    </div>

    <div id="controlsContainer">
        <h1 class="text-2xl font-bold mb-4 text-center text-gray-800">Plotter Steuerung</h1>

        <div class="control-panel">
            <h2>1. Objekte hinzufügen</h2>
            <div class="grid grid-cols-3 gap-2">
                <button id="addTextBtn" class="w-full px-4 py-2 bg-blue-600 text-white font-semibold rounded-md shadow-sm hover:bg-blue-700 transition">Text</button>
                <button id="addFractalBtn" class="w-full px-4 py-2 bg-purple-600 text-white font-semibold rounded-md shadow-sm hover:bg-purple-700 transition">Muster</button>
                <button id="addImgBtn" class="w-full px-4 py-2 bg-teal-600 text-white font-semibold rounded-md shadow-sm hover:bg-teal-700 transition">Bild</button>
                <input type="file" id="imageUpload" accept="image/png, image/jpeg" class="hidden">
            </div>
             <p class="text-xs text-gray-500 mt-2 text-center"><b>Steuerung:</b> Mausrad = Zoom, Linksklick = Drehen, <br><b>Strg + Linksklick</b> auf Objekt = Verschieben</p>
        </div>
        
        <div id="objectListPanel" class="control-panel" style="display: none;">
            <h2>2. Objektliste</h2>
            <ul id="objectList" class="space-y-1"></ul>
        </div>

        <div id="propertiesPanel" class="control-panel">
            </div>

        <div class="control-panel">
            <h2>G-Code Generierung</h2>
            <div class="grid grid-cols-2 gap-4 mb-4">
                <div><label class="block config-label mb-1">Schreibhöhe Z:</label><input type="number" id="writingZ" value="7.5" step="0.5" class="config-input"></div>
                <div><label class="block config-label mb-1">Fahrhöhe Z:</label><input type="number" id="travelZ" value="14.0" step="0.5" class="config-input"></div>
                <div><label class="block config-label mb-1">Schreib-V:</label><input type="number" id="writeSpeed" value="5000" step="100" class="config-input"></div>
                <div><label class="block config-label mb-1">Fahr-V:</label><input type="number" id="travelSpeed" value="45000" step="100" class="config-input"></div>
            </div>
            <button id="generateButton" class="w-full px-6 py-3 bg-indigo-600 text-white font-semibold rounded-md shadow-md hover:bg-indigo-700 transition" disabled>
                G-Code für alle Objekte generieren
            </button>
            <button id="toggleViewBtn" class="w-full mt-2 px-4 py-2 bg-gray-600 text-white font-semibold rounded-md shadow-md hover:bg-gray-700 transition" style="display: none;">
                Ansicht wechseln
            </button>
            <div id="gcodeContainer" class="hidden mt-4">
                 <div id="gcodeOutput">...</div>
                 <button id="downloadButton" class="w-full mt-2 px-4 py-2 bg-green-600 text-white font-semibold rounded-md shadow-md hover:bg-green-700 transition">
                     G-Code herunterladen
                 </button>
                 <div id="simulationControls" class="mt-4" style="display: none;">
                    <label for="simulationSlider" class="block config-label mb-1">Simulations-Fortschritt:</label>
                    <input type="range" id="simulationSlider" min="0" value="0" class="w-full">
                </div>
            </div>
        </div>
    </div>

    <div style="display:none;">
        <template id="textPropertiesTemplate">
            <h2>Eigenschaften: Text</h2>
            <div>
                <label for="propInputText" class="block config-label mb-1">Textinhalt (Großbuchstaben/Zahlen):</label>
                <textarea id="propInputText" rows="4" class="w-full config-input" placeholder="Dein Text..."></textarea>
            </div>
            <div class="grid grid-cols-2 gap-4 mt-2">
                <div><label for="propScale" class="block config-label mb-1">Skalierung:</label><input type="number" id="propScale" value="1.0" step="0.1" min="0.1" class="config-input"></div>
                <div><label for="propCharSpacing" class="block config-label mb-1">Zeichenabst.:</label><input type="number" id="propCharSpacing" value="2.0" step="0.5" min="0" class="config-input"></div>
                <div><label for="propLineSpacing" class="block config-label mb-1">Zeilenabst.:</label><input type="number" id="propLineSpacing" value="5.0" step="0.5" min="0" class="config-input"></div>
                <div><label for="propThickness" class="block config-label mb-1">Schriftdicke:</label><input type="number" id="propThickness" value="0.0" step="0.1" min="0" class="config-input"></div>
            </div>
            <div class="mt-2">
                <label for="propRotation" class="block config-label mb-1">Rotation (°): <span id="rotationValue">0</span></label>
                <input type="range" id="propRotation" min="0" max="360" value="0" class="w-full">
            </div>
        </template>
        <template id="fractalPropertiesTemplate">
            <h2>Eigenschaften: Muster</h2>
            <div>
                <label for="propFractalType" class="block config-label mb-1">Mustertyp:</label>
                <select id="propFractalType" class="config-input">
                    <option value="koch_snowflake">Koch-Schneeflocke</option>
                    <option value="sierpinski_triangle">Sierpinski-Dreieck</option>
                    <option value="hilbert_curve">Hilbert-Kurve</option>
                    <option value="archimedean_spiral">Archimedische Spirale</option>
                </select>
            </div>
            <div class="mt-2">
                <label for="propFractalSize" class="block config-label mb-1">Größe (Breite, mm):</label>
                <input type="number" id="propFractalSize" value="100" min="10" step="10" class="config-input">
            </div>
            <div id="fractalParamsContainer" class="mt-2 space-y-2">
                <div data-fractal="koch_snowflake"><label class="block config-label mb-1">Iterationen:</label><input type="number" id="propKochIterations" value="3" min="0" max="5" step="1" class="config-input"></div>
                <div data-fractal="sierpinski_triangle" style="display:none;"><label class="block config-label mb-1">Iterationen:</label><input type="number" id="propSierpinskiIterations" value="4" min="1" max="7" step="1" class="config-input"></div>
                <div data-fractal="hilbert_curve" style="display:none;"><label class="block config-label mb-1">Ordnung:</label><input type="number" id="propHilbertIterations" value="3" min="1" max="6" step="1" class="config-input"></div>
                <div data-fractal="archimedean_spiral" style="display:none;"><label class="block config-label mb-1">Windungen:</label><input type="number" id="propSpiralTurns" value="5" min="1" step="1" class="config-input"><label class="block config-label mt-2 mb-1">Abstand:</label><input type="number" id="propSpiralSpacing" value="5" min="0.1" step="0.5" class="config-input"></div>
            </div>
            <div class="mt-2">
                <label for="propRotation" class="block config-label mb-1">Rotation (°): <span id="rotationValue">0</span></label>
                <input type="range" id="propRotation" min="0" max="360" value="0" class="w-full">
            </div>
        </template>
        <template id="imagePropertiesTemplate">
            <h2>Eigenschaften: Bild</h2>
            <div>
                <label for="propImageSize" class="block config-label mb-1">Größe (Breite in mm):</label>
                <input type="number" id="propImageSize" value="100" min="10" step="10" class="config-input">
            </div>
            <div class="mt-2">
                <label for="propImageThreshold" class="block config-label mb-1">Schärfe (Schwelle): <span id="thresholdValue">128</span></label>
                <input type="range" id="propImageThreshold" min="1" max="254" value="128" class="w-full">
            </div>
             <div class="mt-2">
                <label for="propImageHatchStyle" class="block config-label mb-1">Schraffur-Typ:</label>
                <select id="propImageHatchStyle" class="config-input">
                    <option value="horizontal">Horizontal</option>
                    <option value="vertical">Vertikal</option>
                    <option value="cross">Gekreuzt</option>
                </select>
            </div>
            <div class="mt-2">
                <label for="propImageHatchDensity" class="block config-label mb-1">Liniendichte: <span id="densityValue">5</span></label>
                <input type="range" id="propImageHatchDensity" min="1" max="20" value="5" class="w-full">
            </div>
            <div class="mt-2">
                <label for="propRotation" class="block config-label mb-1">Rotation (°): <span id="rotationValue">0</span></label>
                <input type="range" id="propRotation" min="0" max="360" value="0" class="w-full">
            </div>
        </template>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- Globale Konstanten & Definitionen ---
        const BED_WIDTH = 245, BED_HEIGHT = 260, PAPER_WIDTH = 210, PAPER_HEIGHT = 297;
        const BASE_CHAR_WIDTH = 10.0, BASE_CHAR_HEIGHT = 10.0;
        const charPaths = {'A':[[{x:0,y:0},{x:5,y:10},{x:10,y:0}],[{x:2.5,y:5},{x:7.5,y:5}]],'B':[[{x:0,y:0},{x:0,y:10}],[{x:0,y:10},{x:6,y:10},{x:9,y:7.5},{x:6,y:5}],[{x:6,y:5},{x:9,y:2.5},{x:6,y:0},{x:0,y:0}]],'C':[[{x:9,y:9},{x:7,y:10},{x:3,y:10},{x:1,y:9},{x:0,y:7.5},{x:0,y:2.5},{x:1,y:1},{x:3,y:0},{x:7,y:0},{x:9,y:1},{x:10,y:2.5},{x:10,y:5}]],'D':[[{x:0,y:0},{x:0,y:10}],[{x:0,y:10},{x:6,y:10},{x:10,y:5},{x:6,y:0},{x:0,y:0}]],'E':[[{x:10,y:0},{x:0,y:0},{x:0,y:10},{x:10,y:10}],[{x:0,y:5},{x:7,y:5}]],'F':[[{x:0,y:0},{x:0,y:10},{x:10,y:10}],[{x:0,y:5},{x:7,y:5}]],'G':[[{x:9,y:9},{x:7,y:10},{x:3,y:10},{x:1,y:9},{x:0,y:7.5},{x:0,y:2.5},{x:1,y:1},{x:3,y:0},{x:7,y:0},{x:9,y:1},{x:10,y:2.5},{x:10,y:5}],[{x:5,y:5},{x:10,y:5}]],'H':[[{x:0,y:0},{x:0,y:10}],[{x:10,y:0},{x:10,y:10}],[{x:0,y:5},{x:10,y:5}]],'I':[[{x:5,y:0},{x:5,y:10}],[{x:2.5,y:0},{x:7.5,y:0}],[{x:2.5,y:10},{x:7.5,y:10}]],'J':[[{x:10,y:10},{x:10,y:2.5},{x:7.5,y:0},{x:2.5,y:0},{x:0,y:2.5}]],'K':[[{x:0,y:0},{x:0,y:10}],[{x:10,y:10},{x:2.5,y:5}],[{x:2.5,y:5},{x:10,y:0}]],'L':[[{x:0,y:10},{x:0,y:0},{x:10,y:0}]],'M':[[{x:0,y:0},{x:0,y:10},{x:5,y:5},{x:10,y:10},{x:10,y:0}]],'N':[[{x:0,y:0},{x:0,y:10},{x:10,y:0},{x:10,y:10}]],'O':[[{x:5,y:0},{x:9,y:1},{x:10,y:2.5},{x:10,y:7.5},{x:9,y:9},{x:5,y:10},{x:1,y:9},{x:0,y:7.5},{x:0,y:2.5},{x:1,y:1},{x:5,y:0}]],'P':[[{x:0,y:0},{x:0,y:10}],[{x:0,y:10},{x:6,y:10},{x:9,y:7.5},{x:6,y:5},{x:0,y:5}]],'Q':[[{x:5,y:0},{x:9,y:1},{x:10,y:2.5},{x:10,y:7.5},{x:9,y:9},{x:5,y:10},{x:1,y:9},{x:0,y:7.5},{x:0,y:2.5},{x:1,y:1},{x:5,y:0}],[{x:7.5,y:2.5},{x:10,y:0}]],'R':[[{x:0,y:0},{x:0,y:10}],[{x:0,y:10},{x:6,y:10},{x:9,y:7.5},{x:6,y:5},{x:0,y:5}],[{x:5,y:5},{x:10,y:0}]],'S':[[{x:9,y:9},{x:7,y:10},{x:3,y:10},{x:1,y:9},{x:0,y:7.5},{x:1,y:6},{x:4,y:5},{x:6,y:5},{x:9,y:4},{x:10,y:2.5},{x:9,y:1},{x:7,y:0},{x:3,y:0},{x:1,y:1},{x:0,y:2.5}]],'T':[[{x:5,y:0},{x:5,y:10}],[{x:0,y:10},{x:10,y:10}]],'U':[[{x:0,y:10},{x:0,y:2.5},{x:2.5,y:0},{x:7.5,y:0},{x:10,y:2.5},{x:10,y:10}]],'V':[[{x:0,y:10},{x:5,y:0},{x:10,y:10}]],'W':[[{x:0,y:10},{x:2.5,y:0},{x:5,y:5},{x:7.5,y:0},{x:10,y:10}]],'X':[[{x:0,y:0},{x:10,y:10}],[{x:10,y:0},{x:0,y:10}]],'Y':[[{x:0,y:10},{x:5,y:5}],[{x:10,y:10},{x:5,y:5}],[{x:5,y:5},{x:5,y:0}]],'Z':[[{x:0,y:10},{x:10,y:10},{x:0,y:0},{x:10,y:0}]],'0':[[{x:5,y:0},{x:9,y:1},{x:10,y:2.5},{x:10,y:7.5},{x:9,y:9},{x:5,y:10},{x:1,y:9},{x:0,y:7.5},{x:0,y:2.5},{x:1,y:1},{x:5,y:0}],[{x:2,y:2},{x:8,y:8}]],'1':[[{x:2.5,y:7.5},{x:5,y:10},{x:5,y:0}],[{x:2.5,y:0},{x:7.5,y:0}]],'2':[[{x:0,y:7.5},{x:2.5,y:10},{x:7.5,y:10},{x:10,y:7.5},{x:0,y:0},{x:10,y:0}]],'3':[[{x:0,y:7.5},{x:2.5,y:10},{x:7.5,y:10},{x:10,y:7.5},{x:7.5,y:5},{x:10,y:2.5},{x:7.5,y:0},{x:2.5,y:0},{x:0,y:2.5}],[{x:2,y:5},{x:7.5,y:5}]],'4':[[{x:0,y:10},{x:0,y:5},{x:10,y:5}],[{x:7.5,y:10},{x:7.5,y:0}]],'5':[[{x:10,y:10},{x:0,y:10},{x:0,y:5},{x:7.5,y:5},{x:10,y:2.5},{x:7.5,y:0},{x:2.5,y:0},{x:0,y:2.5}]],'6':[[{x:10,y:7.5},{x:7.5,y:10},{x:2.5,y:10},{x:0,y:5},{x:2.5,y:0},{x:7.5,y:0},{x:10,y:2.5},{x:7.5,y:5},{x:2.5,y:5}]],'7':[[{x:0,y:10},{x:10,y:10},{x:5,y:0}]],'8':[[{x:2.5,y:5},{x:0,y:7.5},{x:2.5,y:10},{x:7.5,y:10},{x:10,y:7.5},{x:7.5,y:5}],[{x:7.5,y:5},{x:10,y:2.5},{x:7.5,y:0},{x:2.5,y:0},{x:0,y:2.5},{x:2.5,y:5}]],'9':[[{x:0,y:2.5},{x:2.5,y:0},{x:7.5,y:0},{x:10,y:5},{x:7.5,y:10},{x:2.5,y:10},{x:0,y:7.5},{x:2.5,y:5},{x:7.5,y:5}]],'.':[[{x:5,y:0},{x:5,y:1}]],',':[[{x:5,y:1},{x:4,y:-1}]],'!':[[{x:5,y:10},{x:5,y:2.5}],[{x:5,y:0},{x:5,y:1}]],'.':[[{x:0,y:7.5},{x:2.5,y:10},{x:7.5,y:10},{x:10,y:7.5},{x:7.5,y:5},{x:5,y:5},{x:5,y:2.5}],[{x:5,y:0},{x:5,y:1}]]};

        // --- three.js und App-Status Variablen ---
        let scene, camera, renderer, controls, raycaster, pointer, plane;
        let sceneObjects = [];
        let selectedObject = null;
        let objectMeshes = [];
        let isDragging = false;
        let dragOffset = new THREE.Vector3();
        let currentView = 'design';

        // --- UI Elemente ---
        const propertiesPanel = document.getElementById('propertiesPanel');
        const objectListPanel = document.getElementById('objectListPanel');
        const objectList = document.getElementById('objectList');
        const generateButton = document.getElementById('generateButton');
        const downloadButton = document.getElementById('downloadButton');
        const gcodeContainer = document.getElementById('gcodeContainer');
        const gcodeOutput = document.getElementById('gcodeOutput');
        const imageUpload = document.getElementById('imageUpload');
        const toggleViewBtn = document.getElementById('toggleViewBtn');
        
        // --- Initialisierung ---
        function init() {
            const container = document.getElementById('canvasContainer');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x2d3748);

            const aspect = container.clientWidth / container.clientHeight;
            const frustumSize = BED_HEIGHT * 1.1; // Frustum larger than paper
            camera = new THREE.OrthographicCamera(frustumSize * aspect / -2, frustumSize * aspect / 2, frustumSize / 2, frustumSize / -2, 0.1, 2000);
            camera.position.set(BED_WIDTH / 2, BED_HEIGHT / 2, 500);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);
            document.getElementById('loadingText').remove();

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.target.set(BED_WIDTH / 2, BED_HEIGHT / 2, 0);
            controls.enableDamping = true;
            controls.enableRotate = false; // Disable rotation for 2D view

            scene.add(new THREE.AmbientLight(0xffffff, 0.8));
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
            dirLight.position.set(100, 100, 200);
            scene.add(dirLight);

            const gridHelper = new THREE.GridHelper(Math.max(BED_WIDTH, BED_HEIGHT), 20, 0x555555, 0x4a5568);
            gridHelper.rotation.x = Math.PI / 2;
            gridHelper.position.set(BED_WIDTH / 2, BED_HEIGHT / 2, -0.1);
            scene.add(gridHelper);

            const paperMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide, transparent: true, opacity: 0.95 });
            const paperMesh = new THREE.Mesh(new THREE.PlaneGeometry(PAPER_WIDTH, PAPER_HEIGHT), paperMaterial);
            paperMesh.position.set(PAPER_WIDTH / 2, PAPER_HEIGHT / 2, 0);
            scene.add(paperMesh);

            // Safe zone visualization
            const safeAreaWidth = PAPER_WIDTH - 25 - 25; // 25mm margin left/right
            const safeAreaHeight = PAPER_HEIGHT - 70 - 30; // 70mm top, 30mm bottom
            const safeAreaGeometry = new THREE.PlaneGeometry(safeAreaWidth, safeAreaHeight);
            const safeAreaMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide, transparent: true, opacity: 0.1 });
            const safeAreaMesh = new THREE.Mesh(safeAreaGeometry, safeAreaMaterial);
            safeAreaMesh.position.set(PAPER_WIDTH / 2, 30 + safeAreaHeight / 2, 0.01);
            scene.add(safeAreaMesh);

            plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
            raycaster = new THREE.Raycaster();
            pointer = new THREE.Vector2();

            renderer.domElement.addEventListener('pointerdown', onPointerDown, false);
            renderer.domElement.addEventListener('pointermove', onPointerMove, false);
            renderer.domElement.addEventListener('pointerup', onPointerUp, false);
            window.addEventListener('resize', onWindowResize, false);

            animate();
        }
        
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            const container = document.getElementById('canvasContainer');
            const aspect = container.clientWidth / container.clientHeight;
            const frustumSize = BED_HEIGHT * 1.1;
            camera.left = frustumSize * aspect / -2;
            camera.right = frustumSize * aspect / 2;
            camera.top = frustumSize / 2;
            camera.bottom = frustumSize / -2;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        // --- Interaktions-Logik (Strg + Klick) ---
        function onPointerDown(event) {
            if (event.ctrlKey) {
                updatePointer(event);
                raycaster.setFromCamera(pointer, camera);
                const intersects = raycaster.intersectObjects(objectMeshes, true);

                if (intersects.length > 0) {
                    event.preventDefault();
                    const intersectedMesh = findParentGroup(intersects[0].object);
                    if (intersectedMesh) {
                        selectObjectById(intersectedMesh.userData.id);
                        isDragging = true;
                        controls.enabled = false;
                        const intersectionPoint = new THREE.Vector3();
                        raycaster.ray.intersectPlane(plane, intersectionPoint);
                        dragOffset.copy(intersectionPoint).sub(selectedObject.mesh.position);
                    }
                }
            }
        }
        
        function onPointerMove(event) {
            if (isDragging && selectedObject) {
                event.preventDefault();
                updatePointer(event);
                const intersectionPoint = new THREE.Vector3();
                raycaster.setFromCamera(pointer, camera);
                raycaster.ray.intersectPlane(plane, intersectionPoint);
                let newPos = intersectionPoint.sub(dragOffset);

                // Constrain to safe zone
                const safeXMin = 25;
                const safeXMax = PAPER_WIDTH - 25;
                const safeYMin = 30;
                const safeYMax = PAPER_HEIGHT - 70;

                const objectWidth = selectedObject.mesh.children[1].geometry.parameters.width;
                const objectHeight = selectedObject.mesh.children[1].geometry.parameters.height;

                const angleRad = THREE.MathUtils.degToRad(selectedObject.data.properties.rotation || 0);
                const cosA = Math.abs(Math.cos(angleRad));
                const sinA = Math.abs(Math.sin(angleRad));

                const rotatedWidth = objectWidth * cosA + objectHeight * sinA;
                const rotatedHeight = objectWidth * sinA + objectHeight * cosA;

                newPos.x = Math.max(safeXMin + rotatedWidth / 2, Math.min(safeXMax - rotatedWidth / 2, newPos.x));
                newPos.y = Math.max(safeYMin + rotatedHeight / 2, Math.min(safeYMax - rotatedHeight / 2, newPos.y));

                selectedObject.mesh.position.copy(newPos);
                selectedObject.data.position.x = newPos.x;
                selectedObject.data.position.y = newPos.y;
            }
        }

        function onPointerUp(event) {
            isDragging = false;
            controls.enabled = true;
        }

        function updatePointer(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        }

        function findParentGroup(object) {
            let parent = object;
            while(parent) {
                if(parent.isGroup && parent.userData.id) return parent;
                parent = parent.parent;
            }
            return null;
        }
        
        // --- Objekt-Management ---
        function addObject(type, data = {}) {
            const newId = Date.now();
            const defaultPosition = { x: PAPER_WIDTH / 2, y: 30 + (PAPER_HEIGHT - 70 - 30) / 2 };
            let newObjectData;

            switch (type) {
                case 'text':
                    newObjectData = { id: newId, type, content: 'NEUER TEXT', position: defaultPosition, properties: { scale: 1.0, charSpacing: 2.0, lineSpacing: 5.0, thickness: 0.0, rotation: 0 } };
                    break;
                case 'fractal':
                    newObjectData = { id: newId, type, position: defaultPosition, properties: { fractalType: 'koch_snowflake', size: 100, iterations: 3, turns: 5, spacing: 5, rotation: 0 } };
                    break;
                case 'image':
                    if (!data.imageData) return;
                    const imgProps = { size: 100, threshold: 128, hatchStyle: 'horizontal', hatchDensity: 5, rotation: 0 };
                    newObjectData = { id: newId, type, position: defaultPosition, properties: imgProps, originalImageData: data.imageData, tracedLines: traceImage(data.imageData, imgProps.threshold, imgProps.hatchStyle, imgProps.hatchDensity) };
                    break;
                default: return;
            }
            sceneObjects.push(newObjectData);
            renderAllObjects();
            selectObjectById(newId);
            updateObjectList();
            generateButton.disabled = false;
            objectListPanel.style.display = 'block';
        }

        function deleteObject(id) {
            sceneObjects = sceneObjects.filter(obj => obj.id !== id);
            if (selectedObject && selectedObject.data.id === id) {
                selectedObject = null;
                propertiesPanel.style.display = 'none';
            }
            renderAllObjects();
            updateObjectList();
            if (sceneObjects.length === 0) {
                generateButton.disabled = true;
                objectListPanel.style.display = 'none';
            }
        }

        function selectObjectById(id) {
            const objData = sceneObjects.find(obj => obj.id === id);
            if (!objData) return;
            
            const objMesh = objectMeshes.find(m => m.userData.id === id);
            if (!objMesh) return;
            
            selectedObject = { data: objData, mesh: objMesh };
            
            objectMeshes.forEach(m => m.children[1].material.color.set(0x00aaff));
            objMesh.children[1].material.color.set(0xffa500);
            
            updatePropertiesPanel();
            updateObjectList();
        }

        // --- Bildverarbeitung ---
        function handleImageUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);
                    const imageData = ctx.getImageData(0, 0, img.width, img.height);
                    addObject('image', { imageData });
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
            event.target.value = '';
        }

        function traceImage(imageData, threshold, hatchStyle = 'horizontal', hatchDensity = 1) {
            const lines = [];
            const { data, width, height } = imageData;
            hatchDensity = Math.max(1, hatchDensity);

            const getBrightness = (x, y) => {
                const i = (y * width + x) * 4;
                return 0.299 * data[i] + 0.587 * data[i+1] + 0.114 * data[i+2];
            };

            const traceDiagonal = (angle) => {
                const step = hatchDensity;
                const rad = angle * Math.PI / 180;
                const cos = Math.cos(rad);
                const sin = Math.sin(rad);

                for (let i = 0; i < width + height; i += step) {
                    let inLine = false;
                    let p1 = null;

                    for (let j = 0; j < Math.max(width, height) * 2; j++) {
                        const x = Math.round(i * cos - j * sin);
                        const y = Math.round(i * sin + j * cos);

                        if (x >= 0 && x < width && y >= 0 && y < height) {
                            const brightness = getBrightness(x, y);
                            if (!inLine && brightness < threshold) {
                                inLine = true;
                                p1 = { x, y };
                            } else if (inLine && brightness >= threshold) {
                                inLine = false;
                                if (p1) {
                                    lines.push({ x1: p1.x, y1: p1.y, x2: x, y2: y });
                                    p1 = null;
                                }
                            }
                        } else {
                            if (inLine && p1) {
                                inLine = false;
                                lines.push({ x1: p1.x, y1: p1.y, x2: x, y2: y });
                                p1 = null;
                            }
                        }
                    }
                     if (inLine && p1) {
                        const x = Math.round(i * cos - (Math.max(width, height) * 2 -1) * sin);
                        const y = Math.round(i * sin + (Math.max(width, height) * 2-1) * cos);
                        lines.push({ x1: p1.x, y1: p1.y, x2: x, y2: y });
                    }
                }
            };

            switch (hatchStyle) {
                case 'horizontal':
                    traceDiagonal(0);
                    break;
                case 'vertical':
                    traceDiagonal(90);
                    break;
                case 'cross':
                    traceDiagonal(45);
                    traceDiagonal(-45);
                    break;
                default:
                    traceDiagonal(0);
            }
            return lines;
        }

        // --- Rendering & UI Updates ---
        let simulationSegments = [];
        function renderAllObjects() {
            const simGroup = scene.getObjectByName('simulationGroup');
            if (simGroup) simGroup.visible = false;

            objectMeshes.forEach(mesh => {
                scene.remove(mesh);
                mesh.children.forEach(child => {
                    child.geometry?.dispose();
                    child.material?.dispose();
                });
            });
            objectMeshes = [];

            sceneObjects.forEach(objData => {
                const points = getObjectPoints(objData);
                const material = new THREE.LineBasicMaterial({ color: 0xc53030, linewidth: 2 });
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const line = new THREE.LineSegments(geometry, material);

                geometry.computeBoundingBox();
                const box = geometry.boundingBox;
                const size = new THREE.Vector3();
                box.getSize(size);
                
                const boxColor = (selectedObject && selectedObject.data.id === objData.id) ? 0xffa500 : 0x00aaff;
                const boxHelper = new THREE.Mesh(
                    new THREE.PlaneGeometry(Math.max(size.x, 1), Math.max(size.y, 1)),
                    new THREE.MeshBasicMaterial({ color: boxColor, transparent: true, opacity: 0.25, side: THREE.DoubleSide })
                );
                
                const group = new THREE.Group();
                group.add(line);
                group.add(boxHelper);
                
                const center = new THREE.Vector3();
                box.getCenter(center);
                line.position.sub(center);
                
                group.position.set(objData.position.x, objData.position.y, 0.1);
                group.rotation.z = THREE.MathUtils.degToRad(objData.properties.rotation || 0);
                group.userData.id = objData.id;
                
                scene.add(group);
                objectMeshes.push(group);
            });
            setView(currentView);
        }
        
        function updateObjectList() {
            objectList.innerHTML = '';
            sceneObjects.forEach(obj => {
                const li = document.createElement('li');
                li.dataset.id = obj.id;
                if(selectedObject && selectedObject.data.id === obj.id) li.classList.add('selected');
                
                let name = obj.type.charAt(0).toUpperCase() + obj.type.slice(1);
                if(obj.type === 'text') name += `: "${obj.content.substring(0, 15)}..."`;
                if(obj.type === 'fractal') name += `: ${obj.properties.fractalType.replace(/_/g, ' ')}`;
                li.innerHTML = `<span>${name}</span><button class="delete-btn" data-id="${obj.id}">&#x2716;</button>`;
                
                li.querySelector('.delete-btn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    deleteObject(obj.id);
                });
                li.addEventListener('click', () => selectObjectById(obj.id));
                objectList.appendChild(li);
            });
        }
        
        function updatePropertiesPanel() {
            if (!selectedObject) {
                propertiesPanel.style.display = 'none';
                return;
            }
            propertiesPanel.style.display = 'block';
            propertiesPanel.innerHTML = '';
            propertiesPanel.classList.remove('highlight-animation');
            void propertiesPanel.offsetWidth;
            propertiesPanel.classList.add('highlight-animation');

            let templateId = selectedObject.data.type + 'PropertiesTemplate';
            const template = document.getElementById(templateId);
            if (!template) return;
            propertiesPanel.appendChild(template.content.cloneNode(true));
            
            const obj = selectedObject.data;
            if (obj.type === 'text') {
                document.getElementById('propInputText').value = obj.content;
                document.getElementById('propInputText').oninput = e => { selectedObject.data.content = e.target.value.toUpperCase(); renderAllObjects(); updateObjectList(); };
                ['scale', 'charSpacing', 'lineSpacing', 'thickness'].forEach(p => {
                    const propName = p.charAt(0).toUpperCase() + p.slice(1);
                    const el = document.getElementById(`prop${propName}`);
                    if (el) {
                        el.value = obj.properties[p];
                        el.oninput = e => {
                            selectedObject.data.properties[p] = parseFloat(e.target.value);
                            renderAllObjects();
                        };
                    }
                });
            } else if (obj.type === 'image') {
                document.getElementById('propImageSize').value = obj.properties.size;
                document.getElementById('propImageSize').oninput = e => { selectedObject.data.properties.size = parseFloat(e.target.value); renderAllObjects(); };
                const thresholdSlider = document.getElementById('propImageThreshold');
                const thresholdValue = document.getElementById('thresholdValue');
                thresholdSlider.value = obj.properties.threshold;
                thresholdValue.textContent = obj.properties.threshold;
                thresholdSlider.oninput = e => {
                    const newThreshold = parseInt(e.target.value);
                    selectedObject.data.properties.threshold = newThreshold;
                    thresholdValue.textContent = newThreshold;
                    selectedObject.data.tracedLines = traceImage(selectedObject.data.originalImageData, newThreshold, selectedObject.data.properties.hatchStyle, selectedObject.data.properties.hatchDensity);
                    renderAllObjects();
                };

                document.getElementById('propImageHatchStyle').value = obj.properties.hatchStyle;
                document.getElementById('propImageHatchStyle').onchange = e => {
                    selectedObject.data.properties.hatchStyle = e.target.value;
                    selectedObject.data.tracedLines = traceImage(selectedObject.data.originalImageData, selectedObject.data.properties.threshold, selectedObject.data.properties.hatchStyle, selectedObject.data.properties.hatchDensity);
                    renderAllObjects();
                };

                const densitySlider = document.getElementById('propImageHatchDensity');
                const densityValue = document.getElementById('densityValue');
                densitySlider.value = obj.properties.hatchDensity;
                densityValue.textContent = obj.properties.hatchDensity;
                densitySlider.oninput = e => {
                    const newDensity = parseInt(e.target.value);
                    selectedObject.data.properties.hatchDensity = newDensity;
                    densityValue.textContent = newDensity;
                    selectedObject.data.tracedLines = traceImage(selectedObject.data.originalImageData, selectedObject.data.properties.threshold, selectedObject.data.properties.hatchStyle, newDensity);
                    renderAllObjects();
                };
            } else if (obj.type === 'fractal') {
                const typeSelect = document.getElementById('propFractalType');
                typeSelect.value = obj.properties.fractalType;
                
                const paramDivs = document.querySelectorAll('#fractalParamsContainer > div');
                const showCorrectParams = () => {
                    paramDivs.forEach(div => div.style.display = 'none');
                    const selectedDiv = document.querySelector(`div[data-fractal="${typeSelect.value}"]`);
                    if(selectedDiv) selectedDiv.style.display = 'block';
                };

                typeSelect.onchange = e => { selectedObject.data.properties.fractalType = e.target.value; showCorrectParams(); renderAllObjects(); updateObjectList();};
                
                document.getElementById('propFractalSize').oninput = e => {selectedObject.data.properties.size = parseFloat(e.target.value); renderAllObjects();};
                document.getElementById('propKochIterations').oninput = e => {selectedObject.data.properties.iterations = parseInt(e.target.value); renderAllObjects();};
                document.getElementById('propSierpinskiIterations').oninput = e => {selectedObject.data.properties.iterations = parseInt(e.target.value); renderAllObjects();};
                document.getElementById('propHilbertIterations').oninput = e => {selectedObject.data.properties.iterations = parseInt(e.target.value); renderAllObjects();};
                document.getElementById('propSpiralTurns').oninput = e => {selectedObject.data.properties.turns = parseInt(e.target.value); renderAllObjects();};
                document.getElementById('propSpiralSpacing').oninput = e => {selectedObject.data.properties.spacing = parseFloat(e.target.value); renderAllObjects();};
                
                showCorrectParams();
            }

            const rotationSlider = document.getElementById('propRotation');
            if (rotationSlider) {
                const rotationValue = document.getElementById('rotationValue');
                rotationSlider.value = selectedObject.data.properties.rotation || 0;
                rotationValue.textContent = rotationSlider.value;
                rotationSlider.oninput = e => {
                    const newRotation = parseInt(e.target.value);
                    selectedObject.data.properties.rotation = newRotation;
                    rotationValue.textContent = newRotation;
                    renderAllObjects();
                };
            }
        }
        
        // --- Punkt- und Pfadgenerierung für Vorschau ---
        const fractalGenerators = { /* ... Fractal math functions ... */ };
        function getObjectPoints(objData) {
            const allPoints = [];
            const { type, properties } = objData;

            if(type === 'text') {
                const strokes = generateTextLineStrokes(objData); // Returns strokes now
                strokes.forEach(stroke => {
                    stroke.forEach(seg => {
                        allPoints.push(new THREE.Vector3(seg.p1.x, seg.p1.y, 0), new THREE.Vector3(seg.p2.x, seg.p2.y, 0));
                    });
                });
            } else if (type === 'image') {
                const { tracedLines, size } = { ...objData, ...properties};
                const scale = size / objData.originalImageData.width;
                tracedLines.forEach(line => {
                    allPoints.push(new THREE.Vector3(line.x1 * scale, -line.y1 * scale, 0), new THREE.Vector3(line.x2 * scale, -line.y2 * scale, 0));
                });
            } else if (type === 'fractal') {
                let pathData = getFractalPath(properties);
                if (pathData.isLineSegments) {
                     pathData.data.forEach(line => allPoints.push(new THREE.Vector3(line.p1.x, line.p1.y, 0), new THREE.Vector3(line.p2.x, line.p2.y, 0)));
                } else {
                    for (let i = 0; i < pathData.data.length - 1; i++) allPoints.push(new THREE.Vector3(pathData.data[i].x, pathData.data[i].y, 0), new THREE.Vector3(pathData.data[i+1].x, pathData.data[i+1].y, 0));
                }
            }
            return allPoints;
        }

        function getFractalPath(props) { /* ... Fractal generation logic ... */ return {data: [], isLineSegments: false}; }


        // --- G-Code Generierung & Simulation ---
        function generateFinalGCode() {
            const config = {
                writingZ: parseFloat(document.getElementById('writingZ').value), travelZ: parseFloat(document.getElementById('travelZ').value),
                writeSpeed: parseInt(document.getElementById('writeSpeed').value), travelSpeed: parseInt(document.getElementById('travelSpeed').value), zSpeed: 300
            };
            let gcode = ["; G-code generiert mit Interaktivem Plotter", "G21 ; Millimeter", "G90 ; Absolute Positionierung", "G28 ; Home All Axes", `G0 Z${config.travelZ.toFixed(2)} F${config.zSpeed}`];
            
            sceneObjects.forEach(obj => {
                gcode.push(`\n; Starte Objekt: ${obj.type} (ID: ${obj.id})`);
                if (obj.type === 'text') gcode.push(...generateTextGcode(obj, config));
                else if (obj.type === 'image') gcode.push(...generateImageGcode(obj, config));
                else if (obj.type === 'fractal') gcode.push(...generateFractalGcode(obj, config));
            });
            
            gcode.push(`\n; Plot beendet`, `G0 Z${(config.travelZ + 10).toFixed(2)} F${config.zSpeed}`, `G0 X0 Y10 F${config.travelSpeed}`, "M84 ; Motoren aus");
            
            gcodeOutput.textContent = gcode.join('\n');
            gcodeContainer.classList.remove('hidden');
            setupSimulation(gcode);
            setView('simulation');
        }

        function setView(viewName) {
            currentView = viewName;
            const simGroup = scene.getObjectByName('simulationGroup');

            if (viewName === 'simulation') {
                if(simGroup) simGroup.visible = true;
                objectMeshes.forEach(m => m.visible = false);
                toggleViewBtn.style.display = 'block';
            } else { // design view
                if(simGroup) simGroup.visible = false;
                objectMeshes.forEach(m => m.visible = true);
            }
        }

        function setupSimulation(gcode) {
            simulationSegments = [];
            let lastPos = { x: 0, y: 0, z: parseFloat(document.getElementById('travelZ').value) };
            const writingZ = parseFloat(document.getElementById('writingZ').value);

            gcode.forEach(line => {
                if (line.startsWith(';') || line.trim() === '') return;

                let newPos = { ...lastPos };
                const gMatch = line.match(/G([01])/i);
                if (!gMatch) return;

                const xMatch = line.match(/X([\d\.-]+)/i);
                const yMatch = line.match(/Y([\d\.-]+)/i);
                const zMatch = line.match(/Z([\d\.-]+)/i);

                if (xMatch) newPos.x = parseFloat(xMatch[1]);
                if (yMatch) newPos.y = parseFloat(yMatch[1]);
                if (zMatch) newPos.z = parseFloat(zMatch[1]);

                if (xMatch || yMatch) {
                    simulationSegments.push({
                        p1: { x: lastPos.x, y: lastPos.y },
                        p2: { x: newPos.x, y: newPos.y },
                        isDrawing: lastPos.z <= writingZ + 0.1
                    });
                }
                lastPos = newPos;
            });

            if (simulationSegments.length === 0) return;

            const slider = document.getElementById('simulationSlider');
            slider.max = simulationSegments.length;
            slider.value = 0;
            document.getElementById('simulationControls').style.display = 'block';

            let simGroup = scene.getObjectByName('simulationGroup');
            if (!simGroup) {
                simGroup = new THREE.Group();
                simGroup.name = 'simulationGroup';
                const simLine = new THREE.Line(new THREE.BufferGeometry(), new THREE.LineBasicMaterial({ color: 0x00ff00, linewidth: 3 }));
                simLine.name = 'simulationLine';
                simGroup.add(simLine);
                const penGeom = new THREE.ConeGeometry(2.5, 10, 8);
                penGeom.translate(0, 5, 0);
                penGeom.rotateX(Math.PI / 2);
                const simPen = new THREE.Mesh(penGeom, new THREE.MeshBasicMaterial({ color: 0xff0000 }));
                simPen.name = 'simulationPen';
                simGroup.add(simPen);
                scene.add(simGroup);
            }

            slider.oninput = (e) => updateSimulation(parseInt(e.target.value));
            updateSimulation(0);
        }

        function updateSimulation(index) {
            const simGroup = scene.getObjectByName('simulationGroup');
            const simulationLine = simGroup.getObjectByName('simulationLine');
            const simulationPen = simGroup.getObjectByName('simulationPen');
            const penOffsetY = 60; // G-code has offset, so simulation needs it too

            const pointsToDraw = [];
            for (let i = 0; i < index; i++) {
                const seg = simulationSegments[i];
                if (seg.isDrawing) {
                    pointsToDraw.push(new THREE.Vector3(seg.p1.x, seg.p1.y - penOffsetY, 0.2), new THREE.Vector3(seg.p2.x, seg.p2.y - penOffsetY, 0.2));
                }
            }
            simulationLine.geometry.setFromPoints(pointsToDraw);

            const currentPoint = (index > 0) ? simulationSegments[index - 1].p2 : {x:0, y:0};
            const isDrawing = (index > 0) ? simulationSegments[index - 1].isDrawing : false;
            simulationPen.position.set(currentPoint.x, currentPoint.y - penOffsetY, 5);
            simulationPen.material.color.set(isDrawing ? 0x00cc00 : 0xcc0000);
        }

        function generateTextGcode(obj, config) {
            let gcode = [];
            const { writingZ, travelZ, writeSpeed, travelSpeed, zSpeed } = config;
            const { position, properties } = obj;
            const { rotation } = properties;

            // Get strokes in local coordinates
            const strokes = generateTextLineStrokes(obj);

            // Create a temporary geometry to find the exact center, mirroring the preview logic
            const allPoints = [];
            strokes.forEach(stroke => {
                stroke.forEach(seg => {
                    allPoints.push(new THREE.Vector3(seg.p1.x, seg.p1.y, 0));
                    allPoints.push(new THREE.Vector3(seg.p2.x, seg.p2.y, 0));
                });
            });
            const geometry = new THREE.BufferGeometry().setFromPoints(allPoints);
            geometry.computeBoundingBox();
            const center = new THREE.Vector3();
            geometry.boundingBox.getCenter(center);

            const angleRad = THREE.MathUtils.degToRad(rotation || 0);
            const cosA = Math.cos(angleRad), sinA = Math.sin(angleRad);

            const transformPoint = (p) => {
                const p_centered = { x: p.x - center.x, y: p.y - center.y };
                const p_rot = { x: p_centered.x * cosA - p_centered.y * sinA, y: p_centered.x * sinA + p_centered.y * cosA };
                return { x: p_rot.x + position.x, y: p_rot.y + position.y };
            };

            strokes.forEach(stroke => {
                if (stroke.length === 0) return;
                // Transform the first point and move to it
                const firstPoint = transformPoint(stroke[0].p1);
                gcode.push(`G0 Z${travelZ.toFixed(2)} F${zSpeed}`);
                gcode.push(`G0 X${(firstPoint.x).toFixed(2)} Y${(firstPoint.y + 60).toFixed(2)} F${travelSpeed}`);

                // Lower pen and draw the rest of the stroke
                gcode.push(`G1 Z${writingZ.toFixed(2)} F${zSpeed}`);

                stroke.forEach(seg => {
                    const p2_final = transformPoint(seg.p2);
                    gcode.push(`G1 X${(p2_final.x).toFixed(2)} Y${(p2_final.y + 60).toFixed(2)} F${writeSpeed}`);
                });
            });
            return gcode;
        }

        function generateTextLineStrokes(objData) {
            const { content, properties } = objData;
            const { scale, charSpacing, lineSpacing, thickness } = properties;

            let allStrokes = [];
            let currentX = 0, currentY = 0;
            let lines = content.toUpperCase().split('\n');
            const lineHeights = lines.map(line => BASE_CHAR_HEIGHT * scale);
            const totalHeight = lineHeights.reduce((a,b) => a+b, 0) + Math.max(0, lines.length - 1) * lineSpacing;
            const lineWidths = lines.map(line => line.split('').reduce((w, char) => w + (charPaths[char] ? BASE_CHAR_WIDTH * scale + charSpacing : 0), 0));
            const maxWidth = Math.max(...lineWidths);
            const centerOffsetX = -maxWidth / 2;
            const centerOffsetY = totalHeight / 2;
            currentY = centerOffsetY;

            lines.forEach((line, lineIndex) => {
                currentX = centerOffsetX + (maxWidth - lineWidths[lineIndex]) / 2;
                currentY -= lineHeights[lineIndex];
                for (const char of line) {
                    if (charPaths[char]) {
                        charPaths[char].forEach(stroke => {
                            const strokeSegments = [];
                            for (let i = 0; i < stroke.length - 1; i++) {
                                const p1 = { x: currentX + stroke[i].x * scale, y: currentY + stroke[i].y * scale };
                                const p2 = { x: currentX + stroke[i+1].x * scale, y: currentY + stroke[i+1].y * scale };
                                strokeSegments.push({ p1, p2 });
                            }
                            allStrokes.push(strokeSegments);

                            if (thickness > 0.01) {
                                const fillDensity = 0.4;
                                const lineCount = Math.floor(thickness / fillDensity);
                                for (let j = 1; j <= lineCount; j++) {
                                    const currentThickness = j * fillDensity;
                                    const thicknessStrokeSegments = [];
                                    for (let i = 0; i < stroke.length - 1; i++) {
                                        const p1 = { x: currentX + stroke[i].x * scale, y: currentY + stroke[i].y * scale };
                                        const p2 = { x: currentX + stroke[i+1].x * scale, y: currentY + stroke[i+1].y * scale };
                                        const dx = p2.x - p1.x, dy = p2.y - p1.y, len = Math.sqrt(dx * dx + dy * dy);
                                        if (len > 0) {
                                            const perp = { x: -dy / len, y: dx / len };
                                            const p1_offset = { x: p1.x + perp.x * currentThickness, y: p1.y + perp.y * currentThickness };
                                            const p2_offset = { x: p2.x + perp.x * currentThickness, y: p2.y + perp.y * currentThickness };
                                            thicknessStrokeSegments.push({ p1: p1_offset, p2: p2_offset });
                                        }
                                    }
                                    allStrokes.push(thicknessStrokeSegments);
                                }
                            }
                        });
                    }
                    currentX += BASE_CHAR_WIDTH * scale + charSpacing;
                }
                currentY -= lineSpacing;
            });

            return allStrokes;
        }

        function generateImageGcode(obj, config) {
            let gcode = [];
            const { position, properties, tracedLines, originalImageData } = obj;
            const { writingZ, travelZ, writeSpeed, travelSpeed, zSpeed } = config;
            const { size, rotation } = properties;

            const scale = size / originalImageData.width;
            const centerOffsetX = -size / 2;
            const centerOffsetY = (originalImageData.height * scale) / 2;

            const angleRad = THREE.MathUtils.degToRad(rotation || 0);
            const cosA = Math.cos(angleRad), sinA = Math.sin(angleRad);

            tracedLines.forEach(line => {
                let p1_local = { x: line.x1 * scale + centerOffsetX, y: -line.y1 * scale + centerOffsetY };
                let p2_local = { x: line.x2 * scale + centerOffsetX, y: -line.y2 * scale + centerOffsetY };

                const p1_rot = { x: p1_local.x * cosA - p1_local.y * sinA, y: p1_local.x * sinA + p1_local.y * cosA };
                const p2_rot = { x: p2_local.x * cosA - p2_local.y * sinA, y: p2_local.x * sinA + p2_local.y * cosA };

                const p1_final = { x: p1_rot.x + position.x, y: p1_rot.y + position.y };
                const p2_final = { x: p2_rot.x + position.x, y: p2_rot.y + position.y };

                gcode.push(`G0 Z${travelZ.toFixed(2)} F${zSpeed}`, `G0 X${(p1_final.x).toFixed(2)} Y${(p1_final.y + 60).toFixed(2)} F${travelSpeed}`, `G1 Z${writingZ.toFixed(2)} F${zSpeed}`, `G1 X${(p2_final.x).toFixed(2)} Y${(p2_final.y + 60).toFixed(2)} F${writeSpeed}`);
            });
            return gcode;
        }

        function generateFractalGcode(obj, config) {
            let gcode = [];
            const { position, properties } = obj;
            const { writingZ, travelZ, writeSpeed, travelSpeed, zSpeed } = config;
            const { rotation } = properties;

            const pathInfo = getFractalPath(properties);
            if (!pathInfo || pathInfo.data.length === 0) return ["; FEHLER"];

            const angleRad = THREE.MathUtils.degToRad(rotation || 0);
            const cosA = Math.cos(angleRad), sinA = Math.sin(angleRad);

            const transform = p => {
                const p_rot = { x: p.x * cosA - p.y * sinA, y: p.x * sinA + p.y * cosA };
                return { x: p_rot.x + position.x, y: p_rot.y + position.y };
            };

            if (pathInfo.isLineSegments) {
                pathInfo.data.forEach(line => {
                    const s = transform(line.p1), e = transform(line.p2);
                    gcode.push(`G0 Z${travelZ.toFixed(2)} F${zSpeed}`, `G0 X${(s.x).toFixed(2)} Y${(s.y + 60).toFixed(2)} F${travelSpeed}`, `G1 Z${writingZ.toFixed(2)} F${zSpeed}`, `G1 X${(e.x).toFixed(2)} Y${(e.y + 60).toFixed(2)} F${writeSpeed}`);
                });
            } else {
                const start = transform(pathInfo.data[0]);
                gcode.push(`G0 Z${travelZ.toFixed(2)} F${zSpeed}`, `G0 X${(start.x).toFixed(2)} Y${(start.y + 60).toFixed(2)} F${travelSpeed}`, `G1 Z${writingZ.toFixed(2)} F${zSpeed}`);
                for (let i=1; i<pathInfo.data.length; i++) {
                    const p = transform(pathInfo.data[i]);
                    gcode.push(`G1 X${(p.x).toFixed(2)} Y${(p.y + 60).toFixed(2)} F${writeSpeed}`);
                }
            }
            return gcode;
        }


        // --- Event Listener Binding ---
        document.getElementById('addTextBtn').addEventListener('click', () => addObject('text'));
        document.getElementById('addFractalBtn').addEventListener('click', () => addObject('fractal'));
        document.getElementById('addImgBtn').addEventListener('click', () => imageUpload.click());
        imageUpload.addEventListener('change', handleImageUpload);
        generateButton.addEventListener('click', generateFinalGCode);
        downloadButton.addEventListener('click', () => {
             const blob = new Blob([gcodeOutput.textContent], { type: 'text/plain' });
             const a = document.createElement('a');
             a.href = URL.createObjectURL(blob);
             a.download = `plotter_output_${Date.now()}.gcode`;
             a.click();
             URL.revokeObjectURL(a.href);
        });
        toggleViewBtn.addEventListener('click', () => {
            setView(currentView === 'design' ? 'simulation' : 'design');
        });
        
        init();
        
        // --- HILFSFUNKTIONEN (Fraktale & G-Code) ---
        // (Hier sind alle fehlenden Implementierungen)
        Object.assign(fractalGenerators, {
            kochSegment(p1,p2,d){if(d===0)return[p1,p2];let a=Math.atan2(p2.y-p1.y,p2.x-p1.x),b=Math.sqrt(Math.pow(p2.x-p1.x,2)+Math.pow(p2.y-p1.y,2))/3,c={x:p1.x+(p2.x-p1.x)/3,y:p1.y+(p2.y-p1.y)/3},e={x:c.x+Math.cos(a-Math.PI/3)*b,y:c.y+Math.sin(a-Math.PI/3)*b},f={x:p1.x+2*(p2.x-p1.x)/3,y:p1.y+2*(p2.y-p1.y)/3};return[...this.kochSegment(p1,c,d-1).slice(0,-1),...this.kochSegment(c,e,d-1).slice(0,-1),...this.kochSegment(e,f,d-1).slice(0,-1),...this.kochSegment(f,p2,d-1)]},
            hilbertPath(o){let p="A",r={"A":"-BF+AFA+FB-","B":"+AF-BFB-FA+"};for(let i=0;i<o;i++)p=p.split("").map(c=>r[c]||c).join("");let t=[{x:0,y:0}],a=0;for(let c of p){let l=t[t.length-1];if(c==="F")t.push({x:l.x+Math.cos(a),y:l.y+Math.sin(a)});else if(c==="+")a-=Math.PI/2;else if(c==="-")a+=Math.PI/2}return t}
        });

        getFractalPath = function(props) {
            const { fractalType, size, iterations, turns, spacing } = props;
            let data = [], isLineSegments = false;
            switch(fractalType) {
                case 'koch_snowflake':
                    const h=size*Math.sqrt(3)/2, p1={x:0,y:h*2/3}, p2={x:-size/2,y:-h/3}, p3={x:size/2,y:-h/3};
                    data = [...fractalGenerators.kochSegment(p1,p2,iterations).slice(0,-1),...fractalGenerators.kochSegment(p2,p3,iterations).slice(0,-1),...fractalGenerators.kochSegment(p3,p1,iterations)];
                    break;
                case 'sierpinski_triangle':
                     isLineSegments = true; const h_s = size*Math.sqrt(3)/2, p1_s={x:0,y:h_s*2/3}, p2_s={x:-size/2,y:-h_s/3}, p3_s={x:size/2,y:-h_s/3};
                     const subdivide=(a,b,c,d)=>{if(d===0){data.push({p1:a,p2:b},{p1:b,p2:c},{p1:c,p2:a});return}const m1={x:(a.x+b.x)/2,y:(a.y+b.y)/2},m2={x:(b.x+c.x)/2,y:(b.y+c.y)/2},m3={x:(c.x+a.x)/2,y:(c.y+a.y)/2};subdivide(a,m1,m3,d-1);subdivide(m1,b,m2,d-1);subdivide(m3,m2,c,d-1)};
                     subdivide(p1_s, p2_s, p3_s, iterations);
                    break;
                case 'hilbert_curve':
                     const raw = fractalGenerators.hilbertPath(iterations);
                     const xs = raw.map(p=>p.x), ys = raw.map(p=>p.y);
                     const scale = size / (Math.max(...xs)-Math.min(...xs));
                     data = raw.map(p => ({ x: (p.x-Math.min(...xs))*scale, y:(p.y-Math.min(...ys))*scale }));
                     break;
                case 'archimedean_spiral':
                    const b = spacing/(2*Math.PI), maxAngle=turns*2*Math.PI;
                    for(let i=0;i<=turns*100;i++){let a=(i/(turns*100))*maxAngle,r=b*a;data.push({x:r*Math.cos(a),y:r*Math.sin(a)})}
                    break;
            }
            return {data, isLineSegments};
        }
    });
    </script>
</body>
</html>
